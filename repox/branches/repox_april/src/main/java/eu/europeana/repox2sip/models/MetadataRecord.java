/*
 * Copyright 2007 EDL FOUNDATION
 *
 * Licensed under the EUPL, Version 1.1 or - as soon they
 * will be approved by the European Commission - subsequent
 * versions of the EUPL (the "Licence");
 * you may not use this work except in compliance with the
 * Licence.
 * You may obtain a copy of the Licence at:
 *
 * http://ec.europa.eu/idabc/eupl
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the Licence is
 * distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the Licence for the specific language governing
 * permissions and limitations under the Licence.
 */

package eu.europeana.repox2sip.models;

import javax.persistence.*;
import java.io.Serializable;
import java.util.Date;
import java.util.List;

/**
 * This class contains the MetadataRecord's properties and is used to persist/retrieve into/from the database system.
 *
 * @author Nicola Aloia   <nicola.aloia@isti.cnr.it>
 *         Date: 23-mar-2010
 *         Time: 18.17.22
 */
@Entity
public class MetadataRecord implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    @Column
    private Long id = -1L;

    @Column
    @ManyToMany(targetEntity = Request.class)
    @JoinTable(name = "request_md_record",
            joinColumns = {@JoinColumn(name = "request_id")},
            inverseJoinColumns = {@JoinColumn(name = "md_record_id")})
    private List<Request> requests;

    @Column
    private Long pid;

    @Column
    private String sourceData;

    @Column
    private String contentHash;

    @Column
    private String uniquenessHash;

    @Column
    private String repoxID;

    @Column
    @Temporal(TemporalType.DATE)
    private Date creationDate;

    @Column(nullable = false, name = "repox_metadata_id")
    private String repoxMetadataId;

    @Column
    @Temporal(TemporalType.DATE)
    private Date lastModifiedDate;

    @Column
    private MetadataRecordStatus status;

    /**
     * Get the metadata record identifier used by Repox
     *
     * @return String
     */
    public String getRepoxMetadataId() {
        return repoxMetadataId;
    }

    /**
     * Set the metadata record identifier used by Repox
     *
     * @param repoxMetadataId String
     */
    public void setRepoxMetadataId(String repoxMetadataId) {
        this.repoxMetadataId = repoxMetadataId;
    }

    /**
     * Get the Identifier of the MetadataRecord.  The Identifier value is generated by the server side application. If
     * an error occurs on the server side (e.g. "MetadataRecord Already Exists"), the default value (-1L) is returned.
     *
     * @return - Long - the Request identifier
     */
    public Long getId() {
        return id;
    }

    /**
     * Set the Identifier of the MetadataRecord. This method is used by the Server side application. A value set by the
     * client side application is ignored.
     *
     * @param id - Long
     */
    public void setId(Long id) {
        this.id = id;
    }

    /**
     * Get the (@link Request) to which the metadata record belongs.
     * One record could belongs to many request to maintain history of requests for the same data set.
     *
     * @return List<Request>
     * @see {@link eu.europeana.repox2sip.models.Request}
     */
    public List<Request> getRequests() {
        return requests;
    }

    /**
     * Set the (@link Request) List to which the metadata record belongs.
     * One record could belongs to many request to maintain history of requests for the same data set.
     *
     * @param requests List<Request>
     * @see {@link eu.europeana.repox2sip.models.Request}
     */
    public void setRequests(List<Request> requests) {
        this.requests = requests;
    }


    /**
     * Get the identifier of the process that is managing the record.
     *
     * @return Long
     */
    public Long getPid() {
        return pid;
    }

    /**
     * Set the identifier of the process that is managing the record.
     *
     * @param pid Long
     */
    public void setPid(Long pid) {
        this.pid = pid;
    }

    /**
     * Get the original provider's record.
     *
     * @return String
     */
    public String getSourceData() {
        return sourceData;
    }

    /**
     * Set the original provider's record.
     *
     * @param sourceData String
     */
    public void setSourceData(String sourceData) {
        this.sourceData = sourceData;
    }

    /**
     * Get the hash String representing the record. The hash String is used to compare
     * subsequent submissions of the same record.
     *
     * @return String
     */
    public String getContentHash() {
        return contentHash;
    }

    /**
     * Set the hash String representing the record. The hash String is used to compare
     * subsequent submissions of the same record.
     *
     * @param contentHash String
     */
    public void setContentHash(String contentHash) {
        this.contentHash = contentHash;
    }

    /**
     * Get the hash String representing uniquely the record. This hash String is used to avoid duplicate submissions
     * of the record among different providers.
     *
     * @return String
     */
    public String getUniquenessHash() {
        return uniquenessHash;
    }

    /**
     * Set the hash String representing uniquely the record. This hash String is used to avoid duplicate submissions
     * of the record among different providers.
     *
     * @param uniquenessHash String
     */
    public void setUniquenessHash(String uniquenessHash) {
        this.uniquenessHash = uniquenessHash;
    }

    /**
     * Get the date of the last modification to the record.
     *
     * @return Date
     */
    public Date getLastModifiedDate() {
        return lastModifiedDate;
    }

    /**
     * Set the date of the last modification to the record.
     *
     * @param lastModifiedDate Date
     */
    public void setLastModifiedDate(Date lastModifiedDate) {
        this.lastModifiedDate = lastModifiedDate;
    }

    /**
     * Get the Date of the Request creation.
     *
     * @return Date
     */
    public Date getCreationDate() {
        return creationDate;
    }

    /**
     * Set the Date of the Request creation.
     *
     * @param creationDate Date
     */
    public void setCreationDate(Date creationDate) {
        this.creationDate = creationDate;
    }

    /**
     * Get the status of the MetadataRecord. The (@link MetadataRecordStatus) is used to manage to whole
     * MetadataRecord process.
     *
     * @return MetadataRecordStatus
     * @see {@link eu.europeana.repox2sip.models.MetadataRecordStatus}
     */
    public MetadataRecordStatus getStatus() {
        return status;
    }

    /**
     * Set the status of the MetadataRecord. The (@link MetadataRecordStatus) is used to manage to whole Request process.
     *
     * @param status MetadataRecordStatus
     * @see {@link eu.europeana.repox2sip.models.MetadataRecordStatus}
     */
    public void setStatus(MetadataRecordStatus status) {
        this.status = status;
    }

    public String getRepoxID() {
        return repoxID;
    }

    public void setRepoxID(String repoxID) {
        this.repoxID = repoxID;
    }

    @Override
    public String toString() {
        return "MetadataRecord{" +
                "id=" + id +
                ", requests=" + requests +
                ", pid=" + pid +
                ", sourceData='" + sourceData + '\'' +
                ", contentHash='" + contentHash + '\'' +
                ", uniquenessHash='" + uniquenessHash + '\'' +
                ", repoxID='" + repoxID + '\'' +
                ", creationDate=" + creationDate +
                ", repoxMetadataId='" + repoxMetadataId + '\'' +
                ", lastModifiedDate=" + lastModifiedDate +
                ", status=" + status +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof MetadataRecord)) {
            return false;
        }

        MetadataRecord that = (MetadataRecord) o;

        if (contentHash != null ? !contentHash.equals(that.contentHash) : that.contentHash != null) {
            return false;
        }
        if (creationDate != null ? !creationDate.equals(that.creationDate) : that.creationDate != null) {
            return false;
        }
        if (id != null ? !id.equals(that.id) : that.id != null) {
            return false;
        }
        if (lastModifiedDate != null ? !lastModifiedDate.equals(that.lastModifiedDate) : that.lastModifiedDate != null) {
            return false;
        }
        if (pid != null ? !pid.equals(that.pid) : that.pid != null) {
            return false;
        }
        if (repoxID != null ? !repoxID.equals(that.repoxID) : that.repoxID != null) {
            return false;
        }
        if (repoxMetadataId != null ? !repoxMetadataId.equals(that.repoxMetadataId) : that.repoxMetadataId != null) {
            return false;
        }
        if (requests != null ? !requests.equals(that.requests) : that.requests != null) {
            return false;
        }
        if (sourceData != null ? !sourceData.equals(that.sourceData) : that.sourceData != null) {
            return false;
        }
        if (status != that.status) {
            return false;
        }
        if (uniquenessHash != null ? !uniquenessHash.equals(that.uniquenessHash) : that.uniquenessHash != null) {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode() {
        int result = id != null ? id.hashCode() : 0;
        result = 31 * result + (requests != null ? requests.hashCode() : 0);
        result = 31 * result + (pid != null ? pid.hashCode() : 0);
        result = 31 * result + (sourceData != null ? sourceData.hashCode() : 0);
        result = 31 * result + (contentHash != null ? contentHash.hashCode() : 0);
        result = 31 * result + (uniquenessHash != null ? uniquenessHash.hashCode() : 0);
        result = 31 * result + (repoxID != null ? repoxID.hashCode() : 0);
        result = 31 * result + (creationDate != null ? creationDate.hashCode() : 0);
        result = 31 * result + (repoxMetadataId != null ? repoxMetadataId.hashCode() : 0);
        result = 31 * result + (lastModifiedDate != null ? lastModifiedDate.hashCode() : 0);
        result = 31 * result + (status != null ? status.hashCode() : 0);
        return result;
    }

    /**
     * Compare the given MetadataRecord ignoring the generated Identifier. Needed to avoid duplicated object
     *
     * @param o Object
     * @return boolean
     */
    public boolean equalsIgnoreId(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof MetadataRecord)) {
            return false;
        }

        MetadataRecord that = (MetadataRecord) o;

        if (contentHash != null ? !contentHash.equals(that.contentHash) : that.contentHash != null) {
            return false;
        }
        if (creationDate != null ? !creationDate.equals(that.creationDate) : that.creationDate != null) {
            return false;
        }
        if (lastModifiedDate != null ? !lastModifiedDate.equals(that.lastModifiedDate) : that.lastModifiedDate != null) {
            return false;
        }
        if (pid != null ? !pid.equals(that.pid) : that.pid != null) {
            return false;
        }
        if (repoxID != null ? !repoxID.equals(that.repoxID) : that.repoxID != null) {
            return false;
        }
        if (repoxMetadataId != null ? !repoxMetadataId.equals(that.repoxMetadataId) : that.repoxMetadataId != null) {
            return false;
        }
        if (requests != null ? !requests.equals(that.requests) : that.requests != null) {
            return false;
        }
        if (sourceData != null ? !sourceData.equals(that.sourceData) : that.sourceData != null) {
            return false;
        }
        if (status != that.status) {
            return false;
        }
        if (uniquenessHash != null ? !uniquenessHash.equals(that.uniquenessHash) : that.uniquenessHash != null) {
            return false;
        }

        return true;
    }

}